{
  "active_lock_reason": null,
  "assignee": null,
  "assignees": [],
  "author_association": "CONTRIBUTOR",
  "body": "\r\n*Title*: *Redis prefixed routing*\r\n\r\n*Description*:\r\nHi friends, we'd be interested in adding prefix based routing to the redis proxy filter, but wanted to pitch the idea upstream to see the likelyhood of this feature beeing approved and get initial feedback before I jump into the implementation itself. Still very new to envoy, bare with me \ud83d\ude04 \r\n\r\nAt Shopify we have multiple small pools of redises that we use for isolation purposes yet we would like to use a single envoy proxy (either as a k8s sidecar/daemonset) to connect to theses pools of redises. For example, shopify runs a massive pool of web workers to account for traffic spikes, yet all of the shops data is isolated into a shopify shard. In the event of massive traffic burst, this prevents a single shop from overloading possibly other stores redises and containing the blast radius to a small set of shops. In addition, prefix based routing would allow us to define pools that we can then scale independently by shard.\r\n\r\nSimilar to how [facebook/mcrouter](https://github.com/facebook/mcrouter/wiki/Prefix-routing-setup) supports prefix routing, we would need a similar setup to route the keys to a specific cluster. This would allow the configuration of a single ingress, expose a single port, and let Envoy figure out which upstream pool it needs to route the keys.\r\n\r\nAn alternate approach with envoy would be to configure _N_ redis-proxy filters to listen to _N_ different ports, but this approach is not sustainable as every addition to one of the partition would require a restart of all the envoy proxies to expose the ports. \r\n\r\n*Proposition*\r\n\r\nHere's a rough draft of what I think the API could look like:\r\n\r\n```proto\r\nmessage RedisProxy {\r\n  message RouteMatch {\r\n    // If specified, the route is a prefix rule that must match the beginning of the keys. The proxy will always favor the longest matches.\r\n    string prefix = 1 [(validate.rules).string.min_bytes = 1];;\r\n\r\n    reserved 2; // regex based routing maybe?\r\n\r\n    // Indicates that prefix/path matching should be case insensitive. The default is true.\r\n    google.protobuf.BoolValue case_sensitive = 3;\r\n  }\r\n\r\n  message RouteAction {\r\n    // name of the upstream cluster\r\n    string cluster = 1 [(validate.rules).string.min_bytes = 1];\r\n  }\r\n\r\n  message Route {\r\n    // name of the route, used for instrumentation purposes\r\n    string name = 1;\r\n    \r\n    RouteMatch match = 1 [(validate.rules).message.required = true, (gogoproto.nullable) = false];\r\n    RouteAction route = 2;\r\n  }\r\n\r\n  repeated Route routes = 3 [(gogoproto.nullable) = false];\r\n\r\n  // already existing parameter. This essentially becomes the equivalent of mcrouter \"wildcard pool\"\r\n  string cluster = 2 [(validate.rules).string.min_bytes = 1];\r\n}\r\n```\r\n\r\nThe API is inspired quite a bit from the [HTTP route configuration](https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/rds.proto), albeit much simpler. I think initially a static list of routes would be sufficient and a next step would be to add RDS support. Much like mcrouter, envoy would *not* mutate the key (e.g. stripping the prefixes) when forwarding it upstream, but that could be added in the future if needed.\r\n\r\nI'd be happy to help implementing this feature, any early feedback is very welcome \ud83d\ude4f ",
  "closed_at": "2019-02-21T22:10:36Z",
  "closed_by": {
    "avatar_url": "https://avatars3.githubusercontent.com/in/1724?v=4",
    "events_url": "https://api.github.com/users/stale%5Bbot%5D/events{/privacy}",
    "followers_url": "https://api.github.com/users/stale%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/stale%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/stale%5Bbot%5D/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/apps/stale",
    "id": 26384082,
    "login": "stale[bot]",
    "node_id": "MDM6Qm90MjYzODQwODI=",
    "organizations_url": "https://api.github.com/users/stale%5Bbot%5D/orgs",
    "received_events_url": "https://api.github.com/users/stale%5Bbot%5D/received_events",
    "repos_url": "https://api.github.com/users/stale%5Bbot%5D/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/stale%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/stale%5Bbot%5D/subscriptions",
    "type": "Bot",
    "url": "https://api.github.com/users/stale%5Bbot%5D"
  },
  "comments": 5,
  "comments_url": "https://api.github.com/repos/envoyproxy/envoy/issues/5609/comments",
  "created_at": "2019-01-15T18:31:09Z",
  "events_url": "https://api.github.com/repos/envoyproxy/envoy/issues/5609/events",
  "html_url": "https://github.com/envoyproxy/envoy/issues/5609",
  "id": 399476879,
  "labels": [
    {
      "color": "c5def5",
      "default": false,
      "description": "Needs design doc/proposal before implementation",
      "id": 620444894,
      "name": "design proposal",
      "node_id": "MDU6TGFiZWw2MjA0NDQ4OTQ=",
      "url": "https://api.github.com/repos/envoyproxy/envoy/labels/design%20proposal"
    },
    {
      "color": "bfd4f2",
      "default": false,
      "description": "stalebot believes this issue/PR has not been touched recently",
      "id": 867150379,
      "name": "stale",
      "node_id": "MDU6TGFiZWw4NjcxNTAzNzk=",
      "url": "https://api.github.com/repos/envoyproxy/envoy/labels/stale"
    }
  ],
  "labels_url": "https://api.github.com/repos/envoyproxy/envoy/issues/5609/labels{/name}",
  "locked": false,
  "milestone": null,
  "node_id": "MDU6SXNzdWUzOTk0NzY4Nzk=",
  "number": 5609,
  "performed_via_github_app": null,
  "repository_url": "https://api.github.com/repos/envoyproxy/envoy",
  "state": "closed",
  "title": "Redis prefixed routing",
  "updated_at": "2019-02-21T22:10:36Z",
  "url": "https://api.github.com/repos/envoyproxy/envoy/issues/5609",
  "user": {
    "avatar_url": "https://avatars2.githubusercontent.com/u/801405?v=4",
    "events_url": "https://api.github.com/users/maximebedard/events{/privacy}",
    "followers_url": "https://api.github.com/users/maximebedard/followers",
    "following_url": "https://api.github.com/users/maximebedard/following{/other_user}",
    "gists_url": "https://api.github.com/users/maximebedard/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/maximebedard",
    "id": 801405,
    "login": "maximebedard",
    "node_id": "MDQ6VXNlcjgwMTQwNQ==",
    "organizations_url": "https://api.github.com/users/maximebedard/orgs",
    "received_events_url": "https://api.github.com/users/maximebedard/received_events",
    "repos_url": "https://api.github.com/users/maximebedard/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/maximebedard/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/maximebedard/subscriptions",
    "type": "User",
    "url": "https://api.github.com/users/maximebedard"
  }
}