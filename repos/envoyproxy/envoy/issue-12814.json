{
  "active_lock_reason": null,
  "assignee": null,
  "assignees": [],
  "author_association": "CONTRIBUTOR",
  "body": "**TL;DR:** For headers-only responses, we need a way to tell the FilterManager in `encodeHeaders` that we want to add body to this response without having it readily available (i.e don't end stream after sending headers downstream).\r\n\r\nI am working on the HTTP CacheFilter. When a cached response is being revalidated, a 304 (not modified) response (headers only) means that the cached response is valid. In this scenario, the CacheFilter (currently) updates the headers in `encodeHeaders`,  stops iteration, and requests the cached response from the cache. The cache fetches the cached response along several chunks of data. Whenever a chunk is ready, the CacheFilter calls `StreamEncoderFilterCallbacks::addEncodedData` to add it to the body. After the whole cached response is added, the CacheFilter calls `StreamEncoderFilterCallbacks::continueEncoding` to resume encoding with the full response.\r\n\r\nThis approach has several problems:\r\n- The headers and body are held until the response fully available, which incurs a delay. \r\n- The memory usage for buffering the whole response may be high, and it may cause a buffer overflow.\r\n\r\nIdeally we would stream headers and body chunks downstream whenever they are available. We could use `injectEncodedDataToFilterChain` instead of `addEncodedData` to directly pass the data chunks as they arrive. However, the problem is (AFAIK) there's no current way in the filters api to \"tell\" the HCM (or the `FilterManager`) in `encodeHeaders` that there's body that will be added to this response without having it ready. In other words, change `end_stream` to false.\r\n\r\nOne way of changing a headers-only response to a response w/ body without making much changes to the HCM or the API is to call `addEncodedData` in `CacheFilter::encodeHeaders` with an empty body. This will cause data iteration for the response to kick-start after the headers iteration. However, the way `addEncodedData` works now is that if a filter calls it during the `encodeHeaders` callback, and it continues iteration, then the data iteration starts at the next filter downstream. This means the CacheFilter has no way of stopping the data iteration until the cached response is fetched.\r\n\r\nIf acceptable, the default behavior of `addEncodedData` in this case (being called in `encodeHeaders`) can be changed by a small edit to `FilterManager::encodeHeaders`. Specifically changing this if condition:\r\n```\r\n// Here we handle the case where we have a header only response, but a filter adds a body\r\n// to it. We need to not raise end_stream = true to further filters during inline iteration.\r\nif (end_stream && buffered_response_data_ && continue_data_entry == encoder_filters_.end()) {\r\n    continue_data_entry = entry;\r\n}\r\n``` \r\nto:\r\n```\r\n// Here we handle the case where we have a header only response, but a filter adds a body\r\n// to it. We need to not raise end_stream = true to further filters during inline iteration.\r\nif (end_stream && buffered_response_data_ && continue_data_entry == encoder_filters_.end()) {\r\n    continue_data_entry = entry;\r\n    (*entry)->end_stream_ = false;\r\n    (*entry)->iterate_from_current_filter_ = true;\r\n}\r\n```\r\n\r\nCurrently, only a single HTTP filter (json_transcoder) calls `addEncodedData` during `encodeHeaders`. If this default behavior is acceptable we can implement it and fix this filter (maybe by skipping `encodeData` if it was invoked by the filter itself).\r\n\r\nAnother way to do this is to change the `addEncodedData` api and add an extra parameter as whether the filter wants to participate in encoding the data it added. However, (AFAIK) this parameter would only be relevant when the function is called in `encodeHeaders` callbacks, which is not the common case.\r\n\r\nAny other suggestions on ways to accomplish this are highly appreciated!",
  "closed_at": "2020-09-04T15:47:37Z",
  "closed_by": {
    "avatar_url": "https://avatars3.githubusercontent.com/u/6305260?v=4",
    "events_url": "https://api.github.com/users/mattklein123/events{/privacy}",
    "followers_url": "https://api.github.com/users/mattklein123/followers",
    "following_url": "https://api.github.com/users/mattklein123/following{/other_user}",
    "gists_url": "https://api.github.com/users/mattklein123/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/mattklein123",
    "id": 6305260,
    "login": "mattklein123",
    "node_id": "MDQ6VXNlcjYzMDUyNjA=",
    "organizations_url": "https://api.github.com/users/mattklein123/orgs",
    "received_events_url": "https://api.github.com/users/mattklein123/received_events",
    "repos_url": "https://api.github.com/users/mattklein123/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/mattklein123/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mattklein123/subscriptions",
    "type": "User",
    "url": "https://api.github.com/users/mattklein123"
  },
  "comments": 33,
  "comments_url": "https://api.github.com/repos/envoyproxy/envoy/issues/12814/comments",
  "created_at": "2020-08-25T19:52:37Z",
  "events_url": "https://api.github.com/repos/envoyproxy/envoy/issues/12814/events",
  "html_url": "https://github.com/envoyproxy/envoy/issues/12814",
  "id": 685752954,
  "labels": [
    {
      "color": "d4c5f9",
      "default": false,
      "description": "",
      "id": 1715341036,
      "name": "area/http",
      "node_id": "MDU6TGFiZWwxNzE1MzQxMDM2",
      "url": "https://api.github.com/repos/envoyproxy/envoy/labels/area/http"
    }
  ],
  "labels_url": "https://api.github.com/repos/envoyproxy/envoy/issues/12814/labels{/name}",
  "locked": false,
  "milestone": null,
  "node_id": "MDU6SXNzdWU2ODU3NTI5NTQ=",
  "number": 12814,
  "performed_via_github_app": null,
  "repository_url": "https://api.github.com/repos/envoyproxy/envoy",
  "state": "closed",
  "title": "[Feature Request] Allow HTTP filters to add a body that's not readily available to headers-only responses ",
  "updated_at": "2020-09-04T15:47:37Z",
  "url": "https://api.github.com/repos/envoyproxy/envoy/issues/12814",
  "user": {
    "avatar_url": "https://avatars0.githubusercontent.com/u/33295400?v=4",
    "events_url": "https://api.github.com/users/yosrym93/events{/privacy}",
    "followers_url": "https://api.github.com/users/yosrym93/followers",
    "following_url": "https://api.github.com/users/yosrym93/following{/other_user}",
    "gists_url": "https://api.github.com/users/yosrym93/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/yosrym93",
    "id": 33295400,
    "login": "yosrym93",
    "node_id": "MDQ6VXNlcjMzMjk1NDAw",
    "organizations_url": "https://api.github.com/users/yosrym93/orgs",
    "received_events_url": "https://api.github.com/users/yosrym93/received_events",
    "repos_url": "https://api.github.com/users/yosrym93/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/yosrym93/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/yosrym93/subscriptions",
    "type": "User",
    "url": "https://api.github.com/users/yosrym93"
  }
}