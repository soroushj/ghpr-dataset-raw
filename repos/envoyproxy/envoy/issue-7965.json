{
  "active_lock_reason": null,
  "assignee": {
    "avatar_url": "https://avatars0.githubusercontent.com/u/14430883?v=4",
    "events_url": "https://api.github.com/users/nezdolik/events{/privacy}",
    "followers_url": "https://api.github.com/users/nezdolik/followers",
    "following_url": "https://api.github.com/users/nezdolik/following{/other_user}",
    "gists_url": "https://api.github.com/users/nezdolik/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/nezdolik",
    "id": 14430883,
    "login": "nezdolik",
    "node_id": "MDQ6VXNlcjE0NDMwODgz",
    "organizations_url": "https://api.github.com/users/nezdolik/orgs",
    "received_events_url": "https://api.github.com/users/nezdolik/received_events",
    "repos_url": "https://api.github.com/users/nezdolik/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/nezdolik/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nezdolik/subscriptions",
    "type": "User",
    "url": "https://api.github.com/users/nezdolik"
  },
  "assignees": [
    {
      "avatar_url": "https://avatars0.githubusercontent.com/u/14430883?v=4",
      "events_url": "https://api.github.com/users/nezdolik/events{/privacy}",
      "followers_url": "https://api.github.com/users/nezdolik/followers",
      "following_url": "https://api.github.com/users/nezdolik/following{/other_user}",
      "gists_url": "https://api.github.com/users/nezdolik/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/nezdolik",
      "id": 14430883,
      "login": "nezdolik",
      "node_id": "MDQ6VXNlcjE0NDMwODgz",
      "organizations_url": "https://api.github.com/users/nezdolik/orgs",
      "received_events_url": "https://api.github.com/users/nezdolik/received_events",
      "repos_url": "https://api.github.com/users/nezdolik/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/nezdolik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nezdolik/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/nezdolik"
    }
  ],
  "author_association": "NONE",
  "body": "*Description*:\r\nI've seen this when using Kubernetes with Flannel for the network fabric.\r\n\r\nWhen an Envoy container is performing many DNS lookups (or when some DNS lookups become slow enough) that Envoy always has a request in-flight, Envoy becomes effectively \"stuck\" to the same dns pod, even when the DNS pod becomes slow or dies.\r\n\r\nWe have a cluster that has a lot of Envoy services exposed to it, with strict DNS / logical DNS resolution, and I've observed this cause two issues:\r\n1. With many containers performing health checks for a bunch of services, a small slowdown on one DNS pod causes envoy containers doing lookups for health checks to start \"sticking\" to the pod, increasing its load and eventually reaching the point where every DNS query by Envoy in the _entire cluster_ is being routed to a single pod, which overloads.\r\n2. When a node with a DNS pod unexpectedly dies, Envoy continues making DNS requests at that node's now-nonexistent IP, causing DNS to timeout and Envoy to conclude that the service doesn't have any healthy endpoints.\r\n\r\nThis is caused by an interaction of the way Kuberenetes + Flannel do DNS routing, and the way c-ares handles UDP sockets.\r\n\r\n1. Kubernetes services don't trust endpoints to load-balance their requests evenly (See [https://kubernetes.io/docs/concepts/services-networking/#why-not-use-round-robin-dns]), so instead of telling pods about multiple IP addresses, it gives them a single endpoint for DNS and uses [`iptables nat`](https://linux.die.net/man/8/iptables) rules to route packets to various pods. `iptables`' `nat` rules get hit whenever a pod opens a new connection, and they route the connection randomly to a DNS pod. The somewhat surprising thing is that it also considers UDP to have \"connections\", even though it's a connectionless protocol - UDP packets going over an already-open socket to a IP+port that have been hit before don't hit the `nat` tables before getting routed.\r\n1. c-ares, which Envoy is using for DNS, uses the same socket for any requests to the same nameserver, provided one's already open. Since Kube only presents one IP address for DNS resolution, c-ares sees this as a single server, and uses the same socket for all requests, provided that it currently has some requests in flight. Moreover, c-ares ignores any timeouts and errors it gets on the UDP socket, so the socket doesn't close until c-ares isn't waiting for any requests.\r\n\r\nOnce you have an Envoy container making DNS requests (for service lookup or health checks) frequently enough that it always has at least one request in flight, it becomes \"stuck\" to its particular DNS pod, since it always has an open \"connection\" there from iptables' standpoint, and never hits the NAT tables that could send it to a different pod. This becomes more likely when a DNS pod is slow or dead and requests start timing out -- and even when a DNS pod dies and is rescheduled, there's never a chance for Envoy's DNS to hit the NAT table again and have the connection rerouted, so its DNS is still effectively down.\r\n\r\nOn Envoy's end, could you add a config option to force DNS over TCP (through the ARES_FLAG_USEVC flag)? This would solve some of these issues by giving a chance for connections to get killed when DNS is having issues.\r\n\r\n[optional *Relevant Links*:]\r\n\r\n- [IPTables man page](https://linux.die.net/man/8/iptables)\r\n- [Kube service routing](https://kubernetes.io/docs/concepts/services-networking/#why-not-use-round-robin-dns)\r\n- [Ares options](https://github.com/c-ares/c-ares/blob/master/ares_init_options.3)\r\n",
  "closed_at": "2019-12-04T19:26:04Z",
  "closed_by": {
    "avatar_url": "https://avatars1.githubusercontent.com/u/10914751?v=4",
    "events_url": "https://api.github.com/users/htuch/events{/privacy}",
    "followers_url": "https://api.github.com/users/htuch/followers",
    "following_url": "https://api.github.com/users/htuch/following{/other_user}",
    "gists_url": "https://api.github.com/users/htuch/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/htuch",
    "id": 10914751,
    "login": "htuch",
    "node_id": "MDQ6VXNlcjEwOTE0NzUx",
    "organizations_url": "https://api.github.com/users/htuch/orgs",
    "received_events_url": "https://api.github.com/users/htuch/received_events",
    "repos_url": "https://api.github.com/users/htuch/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/htuch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/htuch/subscriptions",
    "type": "User",
    "url": "https://api.github.com/users/htuch"
  },
  "comments": 4,
  "comments_url": "https://api.github.com/repos/envoyproxy/envoy/issues/7965/comments",
  "created_at": "2019-08-19T20:51:22Z",
  "events_url": "https://api.github.com/repos/envoyproxy/envoy/issues/7965/events",
  "html_url": "https://github.com/envoyproxy/envoy/issues/7965",
  "id": 482521611,
  "labels": [
    {
      "color": "84b6eb",
      "default": true,
      "description": "Feature requests. Not bugs or questions.",
      "id": 421403909,
      "name": "enhancement",
      "node_id": "MDU6TGFiZWw0MjE0MDM5MDk=",
      "url": "https://api.github.com/repos/envoyproxy/envoy/labels/enhancement"
    },
    {
      "color": "fbca04",
      "default": true,
      "description": "Needs help!",
      "id": 645516726,
      "name": "help wanted",
      "node_id": "MDU6TGFiZWw2NDU1MTY3MjY=",
      "url": "https://api.github.com/repos/envoyproxy/envoy/labels/help%20wanted"
    }
  ],
  "labels_url": "https://api.github.com/repos/envoyproxy/envoy/issues/7965/labels{/name}",
  "locked": false,
  "milestone": null,
  "node_id": "MDU6SXNzdWU0ODI1MjE2MTE=",
  "number": 7965,
  "performed_via_github_app": null,
  "repository_url": "https://api.github.com/repos/envoyproxy/envoy",
  "state": "closed",
  "title": "When performing many DNS lookups in Kubernetes, Envoy becomes \"stuck\" to one DNS pod",
  "updated_at": "2019-12-04T19:26:04Z",
  "url": "https://api.github.com/repos/envoyproxy/envoy/issues/7965",
  "user": {
    "avatar_url": "https://avatars1.githubusercontent.com/u/30246715?v=4",
    "events_url": "https://api.github.com/users/jpvowen/events{/privacy}",
    "followers_url": "https://api.github.com/users/jpvowen/followers",
    "following_url": "https://api.github.com/users/jpvowen/following{/other_user}",
    "gists_url": "https://api.github.com/users/jpvowen/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/jpvowen",
    "id": 30246715,
    "login": "jpvowen",
    "node_id": "MDQ6VXNlcjMwMjQ2NzE1",
    "organizations_url": "https://api.github.com/users/jpvowen/orgs",
    "received_events_url": "https://api.github.com/users/jpvowen/received_events",
    "repos_url": "https://api.github.com/users/jpvowen/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/jpvowen/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jpvowen/subscriptions",
    "type": "User",
    "url": "https://api.github.com/users/jpvowen"
  }
}