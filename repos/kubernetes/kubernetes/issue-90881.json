{
  "active_lock_reason": null,
  "assignee": null,
  "assignees": [],
  "author_association": "CONTRIBUTOR",
  "body": "# Progress `[8/8]`\r\n* [x] Original approval issue: #88302 \r\n* [x]  [APISnoop mock ticket](https://github.com/cncf/apisnoop/pull/289)\r\n* [x]  test approval issue: [kubernetes/kubernetes#88588](https://github.com/kubernetes/kubernetes/issues/88588)\r\n * [x]  [update and improve](https://github.com/kubernetes/kubernetes/pull/ #90879)\r\n* [x]  test pr : [#90880](https://github.com/kubernetes/kubernetes/pull/90880)\r\n* [x]  two weeks soak start date: [testgrid-link](https://testgrid.k8s.io/google-gce#gci-gce-flaky&include-filter-by-regex=should%20test%20the%20lifecycle%20of%20a%20ReplicationController) Start 9 June 2020 [Master testgrid-link](https://testgrid.k8s.io/google-gce#gce-cos-master-flaky-repro&include-filter-by-regex=should%20test%20the%20lifecycle%20of%20a%20ReplicationController) 3 Flakes\r\n* [x]  two weeks soak end date: [20 Oct 2020](https://testgrid.k8s.io/google-gce#gci-gce-flaky&include-filter-by-regex=should%20test%20the%20lifecycle%20of%20a%20ReplicationController) No Flakes for 2 weeks\r\n* [X]  test promotion pr: [PR](https://github.com/kubernetes/kubernetes/pull/95713)\r\n\r\n\r\n\r\n# Identify an untested feature Using APISnoop\r\nAccording to this APIsnoop query, there are still some remaining ReplicationController endpoints which are untested.\r\n\r\n```\r\nSELECT\r\n  operation_id,\r\n  -- k8s_action,\r\n  path,\r\n  description\r\n  FROM untested_stable_core_endpoints\r\n  where path not like '%volume%'\r\n  and operation_id ilike '%ReplicationController%'\r\n ORDER BY operation_id desc\r\n -- LIMIT 25\r\n       ;\r\n```\r\n\r\n```\r\n                     operation_id                      |                                path                                 |                          description                           \r\n-------------------------------------------------------+---------------------------------------------------------------------+----------------------------------------------------------------\r\n replaceCoreV1NamespacedReplicationControllerStatus    | /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status | replace status of the specified ReplicationController\r\n readCoreV1NamespacedReplicationControllerStatus       | /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status | read status of the specified ReplicationController\r\n patchCoreV1NamespacedReplicationControllerStatus      | /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status | partially update status of the specified ReplicationController\r\n patchCoreV1NamespacedReplicationControllerScale       | /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale  | partially update scale of the specified ReplicationController\r\n patchCoreV1NamespacedReplicationController            | /api/v1/namespaces/{namespace}/replicationcontrollers/{name}        | partially update the specified ReplicationController\r\n listCoreV1ReplicationControllerForAllNamespaces       | /api/v1/replicationcontrollers                                      | list or watch objects of kind ReplicationController\r\n deleteCoreV1CollectionNamespacedReplicationController | /api/v1/namespaces/{namespace}/replicationcontrollers               | delete collection of ReplicationController\r\n(7 rows)\r\n```\r\n\r\n# Use API Reference to Lightly Document the Feature\r\n* [Kubernetes API Reference Docs](https://kubernetes.io/docs/reference/kubernetes-api/)\r\n* [client-go - ReplicationController](https://github.com/kubernetes/client-go/blob/master/kubernetes/typed/core/v1/replicationcontroller.go)\r\n\r\n# The mock test\r\n## Test outline\r\n1. Create a ReplicationController with a static label\r\n2. Patch the ReplicationController with a new Label and updated data\r\n3. Patch the ReplicationController's status\r\n4. Patch/Scale the ReplicationController's Replica count to 2 Replicas\r\n5. Get the ReplicationController\r\n6. Replace the ReplicationController's Status\r\n7. List all ReplicationControllers in all Namespaces find the ReplicationControllers(1) ensure that the ReplicationController is found and is patched\r\n8. Delete Namespaced ReplicationControllers(1) via a Collection with a LabelSelector\r\n\r\n## Example in Go\r\n```go\r\npackage main\r\n\r\nimport (\r\n  \"encoding/json\"\r\n  \"fmt\"\r\n  \"flag\"\r\n  \"os\"\r\n\r\n  v1 \"k8s.io/api/core/v1\"\r\n  metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\r\n  \"k8s.io/client-go/kubernetes\"\r\n  \"k8s.io/apimachinery/pkg/runtime/schema\"\r\n  \"k8s.io/apimachinery/pkg/types\"\r\n  autoscalingv1 \"k8s.io/api/autoscaling/v1\"\r\n  \"k8s.io/client-go/dynamic\"\r\n  \"k8s.io/client-go/tools/clientcmd\"\r\n  //\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\r\n)\r\n\r\nfunc main() {\r\n  // uses the current context in kubeconfig\r\n  kubeconfig := flag.String(\"kubeconfig\", fmt.Sprintf(\"%v/%v/%v\", os.Getenv(\"HOME\"), \".kube\", \"config\"), \"(optional) absolute path to the kubeconfig file\")\r\n  flag.Parse()\r\n  config, err := clientcmd.BuildConfigFromFlags(\"\", *kubeconfig)\r\n  if err != nil {\r\n    fmt.Println(err)\r\n  }\r\n  // make our work easier to find in the audit_event queries\r\n  config.UserAgent = \"live-test-writing\"\r\n  // creates the clientset\r\n  ClientSet, _ := kubernetes.NewForConfig(config)\r\n  DynamicClientSet, _ := dynamic.NewForConfig(config)\r\n  rcResource := schema.GroupVersionResource{Group: \"\", Version: \"v1\", Resource: \"replicationcontrollers\"}\r\n\r\n  testRcName := \"rc-test\"\r\n  testRcNamespace := \"default\"\r\n  testRcInitialReplicaCount := int32(1)\r\n  testRcMaxReplicaCount := int32(2)\r\n\r\n  rcTest := v1.ReplicationController{\r\n      ObjectMeta: metav1.ObjectMeta{\r\n          Name: testRcName,\r\n          Labels: map[string]string{\"test-rc-static\": \"true\"},\r\n      },\r\n      Spec: v1.ReplicationControllerSpec{\r\n          Replicas: &testRcInitialReplicaCount,\r\n          Selector: map[string]string{\"test-rc-static\": \"true\"},\r\n          Template: &v1.PodTemplateSpec{\r\n              ObjectMeta: metav1.ObjectMeta{\r\n                  Name: testRcName,\r\n                  Labels: map[string]string{\"test-rc-static\": \"true\"},\r\n              },\r\n              Spec: v1.PodSpec{\r\n                  Containers: []v1.Container{{\r\n                      Name: testRcName,\r\n                      Image: \"nginx\",\r\n                  }},\r\n              },\r\n          },\r\n      },\r\n  }\r\n\r\n  // Create a ReplicationController\r\n  _, err = ClientSet.CoreV1().ReplicationControllers(testRcNamespace).Create(&rcTest)\r\n  if err != nil {\r\n      fmt.Println(err)\r\n      return\r\n  }\r\n  fmt.Println(\"[status] created ReplicationController\")\r\n\r\n  // setup a watch for the RC\r\n  rcWatch, err := ClientSet.CoreV1().ReplicationControllers(testRcNamespace).Watch(metav1.ListOptions{LabelSelector: \"test-rc-static=true\"})\r\n  if err != nil {\r\n      fmt.Println(err)\r\n      return\r\n  }\r\n  rcWatchChan := rcWatch.ResultChan()\r\n\r\n  fmt.Println(\"[status] watching for all Replicas to be ready\")\r\n  for event := range rcWatchChan {\r\n      rc, ok := event.Object.(*v1.ReplicationController)\r\n      if ok != true {\r\n          fmt.Println(\"Unable to fix type\")\r\n          return\r\n      }\r\n      if rc.Status.Replicas == testRcInitialReplicaCount && rc.Status.ReadyReplicas == testRcInitialReplicaCount {\r\n          break\r\n      }\r\n  }\r\n\r\n  rcLabelPatchPayload, err := json.Marshal(v1.ReplicationController{\r\n      ObjectMeta: metav1.ObjectMeta{\r\n          Labels: map[string]string{\"test-rc\": \"patched\"},\r\n      },\r\n  })\r\n  if err != nil {\r\n    fmt.Println(err)\r\n    return\r\n  }\r\n  // Patch the ReplicationController\r\n  _, err = ClientSet.CoreV1().ReplicationControllers(testRcNamespace).Patch(testRcName, types.StrategicMergePatchType, []byte(rcLabelPatchPayload))\r\n  if err != nil {\r\n    fmt.Println(err)\r\n    return\r\n  }\r\n  fmt.Println(\"[status] patched ReplicationController\")\r\n\r\n  rcStatusPatchPayload, err := json.Marshal(map[string]interface{}{\r\n    \"status\": map[string]interface{}{\r\n      \"readyReplicas\": 0,\r\n      \"availableReplicas\": 0,\r\n    },\r\n  })\r\n  if err != nil {\r\n      fmt.Println(err)\r\n      return\r\n  }\r\n\r\n  // Patch the ReplicationController's status\r\n  rcStatus, err := ClientSet.CoreV1().ReplicationControllers(testRcNamespace).Patch(testRcName, types.StrategicMergePatchType, []byte(rcStatusPatchPayload), \"status\")\r\n  if err != nil {\r\n      fmt.Println(err)\r\n      return\r\n  }\r\n  if rcStatus.Status.ReadyReplicas != 0 {\r\n      fmt.Println(\"[error] failed to patch ReplicationController status; ReadyReplicas != 0\")\r\n      return\r\n  }\r\n  fmt.Println(\"[status] patched status of ReplicationController\")\r\n\r\n  rcStatusUnstructured, err := DynamicClientSet.Resource(rcResource).Namespace(testRcNamespace).Get(testRcName, metav1.GetOptions{}, \"status\")\r\n  if err != nil {\r\n      fmt.Println(err)\r\n      return\r\n  }\r\n  rcStatusUjson, _ := json.Marshal(rcStatusUnstructured)\r\n\tjson.Unmarshal(rcStatusUjson, &rcStatus)\r\n  if rcStatus.Status.Replicas != testRcInitialReplicaCount {\r\n     fmt.Println(\"[error] Replica count does not match initial Replica count\")\r\n  }\r\n  fmt.Println(\"[status] fetched ReplicationController status\")\r\n\r\n  rcScalePatchPayload, err := json.Marshal(autoscalingv1.Scale{\r\n      Spec: autoscalingv1.ScaleSpec{\r\n          Replicas: 2,\r\n      },\r\n  })\r\n  if err != nil {\r\n      fmt.Println(err)\r\n      return\r\n  }\r\n\r\n  // Patch the ReplicationController's scale\r\n  rcScale, err := ClientSet.CoreV1().ReplicationControllers(testRcNamespace).Patch(testRcName, types.StrategicMergePatchType, []byte(rcScalePatchPayload), \"scale\")\r\n  if err != nil {\r\n      fmt.Println(err)\r\n      return\r\n  }\r\n  rcScaleReplicasExpect := int32(2)\r\n  if rcScale.Status.Replicas == rcScaleReplicasExpect {\r\n      fmt.Println(\"[error] failed to patch ReplicationController scale; ReadyReplicas != 2\")\r\n      return\r\n  }\r\n  fmt.Println(\"[status] patched scale of ReplicationController\")\r\n\r\n  fmt.Println(\"[status] watching for all Replicas to be ready\")\r\n  for event := range rcWatchChan {\r\n      rc, ok := event.Object.(*v1.ReplicationController)\r\n      if ok != true {\r\n          fmt.Println(\"Unable to fix type\")\r\n          return\r\n      }\r\n      if rc.Status.Replicas == testRcMaxReplicaCount && rc.Status.ReadyReplicas == testRcMaxReplicaCount {\r\n          break\r\n      }\r\n  }\r\n\r\n  // Get the ReplicationController\r\n  rc, err := ClientSet.CoreV1().ReplicationControllers(testRcNamespace).Get(testRcName, metav1.GetOptions{})\r\n  if err != nil {\r\n      fmt.Println(err)\r\n      return\r\n  }\r\n  if rc.ObjectMeta.Labels[\"test-rc\"] != \"patched\" {\r\n      fmt.Println(err)\r\n      return\r\n  }\r\n  fmt.Println(\"[status] fetched ReplicationController\")\r\n\r\n  rcStatusUpdatePayload := rc\r\n  rcStatusUpdatePayload.Status.AvailableReplicas = 1\r\n  rcStatusUpdatePayload.Status.ReadyReplicas = 1\r\n\r\n  // Replace the ReplicationController's status\t\r\n  rcStatus, err = ClientSet.CoreV1().ReplicationControllers(testRcNamespace).UpdateStatus(rcStatusUpdatePayload)\r\n  if err != nil {\r\n      fmt.Println(err)\r\n      return\r\n  }\r\n  if rcStatus.Status.ReadyReplicas != 1 {\r\n      fmt.Println(\"[error] failed to patch ReplicationController status; ReadyReplicas != 1\")\r\n      return\r\n  }\r\n  fmt.Println(\"[status] updated ReplicationController status\")\r\n\r\n  fmt.Println(\"[status] watching for all Replicas to be ready\")\r\n  for event := range rcWatchChan {\r\n      rc, ok := event.Object.(*v1.ReplicationController)\r\n      if ok != true {\r\n          fmt.Println(\"Unable to fix type\")\r\n          return\r\n      }\r\n      if rc.Status.Replicas == testRcMaxReplicaCount && rc.Status.ReadyReplicas == testRcMaxReplicaCount {\r\n          fmt.Println(\"[status] all Replicas are ready\")\r\n          break\r\n      }\r\n  }\r\n\r\n  rcs, err := ClientSet.CoreV1().ReplicationControllers(\"\").List(metav1.ListOptions{LabelSelector: \"test-rc-static=true\"})\r\n  if err != nil {\r\n      fmt.Println(err)\r\n      return\r\n  }\r\n  if len(rcs.Items) == 0 {\r\n      fmt.Println(\"[error] no ReplicationController were found\")\r\n  }\r\n  foundRc := false\r\n  for _, rcItem := range rcs.Items {\r\n      if rcItem.ObjectMeta.Name == testRcName &&\r\n         rcItem.ObjectMeta.Namespace == testRcNamespace &&\r\n         rcItem.ObjectMeta.Labels[\"test-rc-static\"] == \"true\" &&\r\n         rcItem.ObjectMeta.Labels[\"test-rc\"] == \"patched\" && \r\n         rcItem.Status.Replicas == testRcMaxReplicaCount &&\r\n         rcItem.Status.ReadyReplicas == testRcMaxReplicaCount {\r\n         foundRc = true\r\n      }\r\n  }\r\n  if foundRc == false {\r\n      fmt.Println(\"[error] unable to find ReplicationController\")\r\n      return\r\n  }\r\n  fmt.Println(\"[status] retrieved all ReplicationControllers selecting with LabelSelector\")\r\n\r\n  // Delete ReplicationController\r\n  err = ClientSet.CoreV1().ReplicationControllers(testRcNamespace).DeleteCollection(&metav1.DeleteOptions{}, metav1.ListOptions{LabelSelector: \"test-rc-static=true\"})\r\n  if err != nil {\r\n    fmt.Println(err)\r\n    return\r\n  }\r\n  fmt.Println(\"[status] deleted ReplicationController\")\r\n\r\n  fmt.Println(\"[status] complete\")\r\n\r\n}\r\n```\r\n\r\n```go\r\n[status] created ReplicationController\r\n[status] watching for all Replicas to be ready\r\n[status] patched ReplicationController\r\n[status] patched status of ReplicationController\r\n[status] fetched ReplicationController status\r\n[status] patched scale of ReplicationController\r\n[status] watching for all Replicas to be ready\r\n[status] fetched ReplicationController\r\n[status] updated ReplicationController status\r\n[status] watching for all Replicas to be ready\r\n[status] all Replicas are ready\r\n[status] retrieved all ReplicationControllers selecting with LabelSelector\r\n[status] deleted ReplicationController\r\n[status] complete\r\n```\r\n\r\n# Verify Increase it Coverage with APISnoop\r\nDiscover useragents:\r\n\r\n```\r\nselect distinct useragent from audit_event where bucket='apisnoop' and useragent not like 'kube%' and useragent not like 'coredns%' and useragent not like 'kindnetd%' and useragent like 'live%';\r\n```\r\n\r\n```\r\n     useragent     \r\n-------------------\r\n live-test-writing\r\n(1 row)\r\n```\r\n\r\nSee all endpoints hit from this test\r\n\r\n```\r\nselect * from endpoints_hit_by_new_test where useragent like 'live%'; \r\n```\r\n\r\n```\r\n     useragent     |                     operation_id                      | hit_by_ete | hit_by_new_test \r\n-------------------+-------------------------------------------------------+------------+-----------------\r\n live-test-writing | createCoreV1NamespacedReplicationController           | t          |               2\r\n live-test-writing | deleteCoreV1CollectionNamespacedReplicationController | f          |               2\r\n live-test-writing | listCoreV1NamespacedReplicationController             | t          |               1\r\n live-test-writing | listCoreV1ReplicationControllerForAllNamespaces       | f          |               1\r\n live-test-writing | patchCoreV1NamespacedReplicationController            | f          |               2\r\n live-test-writing | patchCoreV1NamespacedReplicationControllerScale       | f          |               2\r\n live-test-writing | patchCoreV1NamespacedReplicationControllerStatus      | f          |               2\r\n live-test-writing | readCoreV1NamespacedReplicationController             | t          |               1\r\n live-test-writing | readCoreV1NamespacedReplicationControllerStatus       | f          |               1\r\n live-test-writing | replaceCoreV1NamespacedReplicationControllerStatus    | f          |               2\r\n(10 rows)\r\n```\r\n\r\nDisplay test coverage change\r\n\r\n```\r\nselect * from projected_change_in_coverage;\r\n```\r\n\r\n```\r\n   category    | total_endpoints | old_coverage | new_coverage | change_in_number \r\n---------------+-----------------+--------------+--------------+------------------\r\n test_coverage |             438 |          190 |          197 |                7\r\n(1 row)\r\n```\r\n\r\n# Final notes\r\nIf a test with these calls gets merged, ****test coverage will go up by 7 points****\r\n\r\nThis test is also created with the goal of conformance promotion.\r\n\r\n",
  "closed_at": "2020-10-23T05:16:59Z",
  "closed_by": {
    "avatar_url": "https://avatars0.githubusercontent.com/u/20407524?v=4",
    "events_url": "https://api.github.com/users/k8s-ci-robot/events{/privacy}",
    "followers_url": "https://api.github.com/users/k8s-ci-robot/followers",
    "following_url": "https://api.github.com/users/k8s-ci-robot/following{/other_user}",
    "gists_url": "https://api.github.com/users/k8s-ci-robot/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/k8s-ci-robot",
    "id": 20407524,
    "login": "k8s-ci-robot",
    "node_id": "MDQ6VXNlcjIwNDA3NTI0",
    "organizations_url": "https://api.github.com/users/k8s-ci-robot/orgs",
    "received_events_url": "https://api.github.com/users/k8s-ci-robot/received_events",
    "repos_url": "https://api.github.com/users/k8s-ci-robot/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/k8s-ci-robot/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/k8s-ci-robot/subscriptions",
    "type": "User",
    "url": "https://api.github.com/users/k8s-ci-robot"
  },
  "comments": 6,
  "comments_url": "https://api.github.com/repos/kubernetes/kubernetes/issues/90881/comments",
  "created_at": "2020-05-08T03:34:48Z",
  "events_url": "https://api.github.com/repos/kubernetes/kubernetes/issues/90881/events",
  "html_url": "https://github.com/kubernetes/kubernetes/issues/90881",
  "id": 614479888,
  "labels": [
    {
      "color": "0052cc",
      "default": false,
      "description": "Issues or PRs related to kubernetes conformance tests",
      "id": 717986501,
      "name": "area/conformance",
      "node_id": "MDU6TGFiZWw3MTc5ODY1MDE=",
      "url": "https://api.github.com/repos/kubernetes/kubernetes/labels/area/conformance"
    },
    {
      "color": "d2b48c",
      "default": false,
      "description": "Categorizes an issue or PR as relevant to SIG Architecture.",
      "id": 636152047,
      "name": "sig/architecture",
      "node_id": "MDU6TGFiZWw2MzYxNTIwNDc=",
      "url": "https://api.github.com/repos/kubernetes/kubernetes/labels/sig/architecture"
    },
    {
      "color": "d2b48c",
      "default": false,
      "description": "Categorizes an issue or PR as relevant to SIG Testing.",
      "id": 483069764,
      "name": "sig/testing",
      "node_id": "MDU6TGFiZWw0ODMwNjk3NjQ=",
      "url": "https://api.github.com/repos/kubernetes/kubernetes/labels/sig/testing"
    }
  ],
  "labels_url": "https://api.github.com/repos/kubernetes/kubernetes/issues/90881/labels{/name}",
  "locked": false,
  "milestone": null,
  "node_id": "MDU6SXNzdWU2MTQ0Nzk4ODg=",
  "number": 90881,
  "performed_via_github_app": null,
  "repository_url": "https://api.github.com/repos/kubernetes/kubernetes",
  "state": "closed",
  "title": "Write CoreV1ReplicationController lifecycle test+promote - +7 coverage",
  "updated_at": "2020-10-23T05:16:59Z",
  "url": "https://api.github.com/repos/kubernetes/kubernetes/issues/90881",
  "user": {
    "avatar_url": "https://avatars1.githubusercontent.com/u/61125752?v=4",
    "events_url": "https://api.github.com/users/Riaankl/events{/privacy}",
    "followers_url": "https://api.github.com/users/Riaankl/followers",
    "following_url": "https://api.github.com/users/Riaankl/following{/other_user}",
    "gists_url": "https://api.github.com/users/Riaankl/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/Riaankl",
    "id": 61125752,
    "login": "Riaankl",
    "node_id": "MDQ6VXNlcjYxMTI1NzUy",
    "organizations_url": "https://api.github.com/users/Riaankl/orgs",
    "received_events_url": "https://api.github.com/users/Riaankl/received_events",
    "repos_url": "https://api.github.com/users/Riaankl/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/Riaankl/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Riaankl/subscriptions",
    "type": "User",
    "url": "https://api.github.com/users/Riaankl"
  }
}