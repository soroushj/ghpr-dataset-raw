{
  "active_lock_reason": null,
  "assignee": null,
  "assignees": [],
  "author_association": "NONE",
  "body": "**Is this a BUG REPORT or FEATURE REQUEST?** (choose one):    \r\nBUG\r\n\r\n---\r\n\r\n\r\n**Kubernetes version** (use `kubectl version`):    \r\nk8s1.3.5. still exist in 1.6\r\n\r\n---\r\n\r\n**What happened**:    \r\n\r\nwhen exec threadSafeMap.Index func, the returned items contain nil object. That is to say, index is in threadSafeMap but the corresponding has already been deleted.\r\n\r\n---\r\n\r\n\r\n**What you expected to happen**:     \r\nwhen object is deleted from threadSafeMap, **all its index** must be deleted.\r\n\r\n---\r\n\r\n\r\n**How to reproduce it** (as minimally and precisely as possible):  \r\n\r\n\r\nSuppose we init threadSafeMap with two indexers: **indexFunc1 and indexFunc2**.\r\n\r\nObviously, **indexFunc may return error** if the object has something wrong or some other reasons.\r\n\r\nwhen we add an object, will first add the object to threadSafeMap.items, then compute the index and add the index into threadSafe.indices.\r\n\r\n\r\n```\r\nfunc (c *threadSafeMap) Add(key string, obj interface{}) {\r\n\tc.lock.Lock()\r\n\tdefer c.lock.Unlock()\r\n\toldObject := c.items[key]\r\n\tc.items[key] = obj\r\n\tc.updateIndices(oldObject, obj, key)\r\n}\r\n\r\nfunc (c *threadSafeMap) updateIndices(oldObj interface{}, newObj interface{}, key string) error {\r\n\t// if we got an old object, we need to remove it before we add it again\r\n\tif oldObj != nil {\r\n\t\tc.deleteFromIndices(oldObj, key)\r\n\t}\r\n\tfor name, indexFunc := range c.indexers {\r\n\t\tindexValues, err := indexFunc(newObj)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tindex := c.indices[name]\r\n\t\tif index == nil {\r\n\t\t\tindex = Index{}\r\n\t\t\tc.indices[name] = index\r\n\t\t}\r\n\r\n\t\tfor _, indexValue := range indexValues {\r\n\t\t\tset := index[indexValue]\r\n\t\t\tif set == nil {\r\n\t\t\t\tset = sets.String{}\r\n\t\t\t\tindex[indexValue] = set\r\n\t\t\t}\r\n\t\t\tset.Insert(key)\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n```\r\n\r\nwhen we delete the object, will first delete the index from indices, then delete it from threadSafeMap.items.\r\n\r\n```\r\nfunc (c *threadSafeMap) Delete(key string) {\r\n\tc.lock.Lock()\r\n\tdefer c.lock.Unlock()\r\n\tif obj, exists := c.items[key]; exists {\r\n\t\tc.deleteFromIndices(obj, key)\r\n\t\tdelete(c.items, key)\r\n\t}\r\n}\r\n```\r\n\r\nSuppose **IndexFunc1(object) return error and indexFunc2(object) works well**. I think this circumstance is absolutely possible to happen.\r\n\r\nAlso we know that **the order to exec  indexFunc is not decided.** Feature of iterating map.\r\n\r\n\r\n```\r\n\tfor name, indexFunc := range c.indexers {\r\n\t\tindexValues, err := indexFunc(newObj)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t... ...\r\n\t}\r\n```\r\n\r\n\r\nWhen we add object, suppose **first exec indexFunc2, and then exec indexFunc1**.  So the index of indexFunc2 is added to indices. But the index of indexFunc1 is not added, because indexFunc1(obj) return err.\r\n\r\nThen we delete the object, suppose **first exec indexFunc1**. It will return error and IndexFunc2 has no chance to run. So the corresponding index indexFunc2(obj) can't be removed. But then the object is removed from items.\r\n\r\nThis problem may result in subtle problems.\r\nFor example, when we exec threadSafeMap.Index( ) func \uff0cthe returned list may include nil object.\r\n\r\n\r\n---\r\n\r\n\r\n**Anything else we need to know**\r\n\r\nThe reason is that index is still is threadSafeMap but the corresponding object has already been removed.\r\n\r\nWe must clear all corresponding indexs when delete object.\r\n\r\nAnd the reason why index is not deleted is that when for-range map, the order is not decided.\r\n\r\n---\r\n",
  "closed_at": "2017-10-02T21:17:12Z",
  "closed_by": {
    "avatar_url": "https://avatars0.githubusercontent.com/u/13653959?v=4",
    "events_url": "https://api.github.com/users/k8s-github-robot/events{/privacy}",
    "followers_url": "https://api.github.com/users/k8s-github-robot/followers",
    "following_url": "https://api.github.com/users/k8s-github-robot/following{/other_user}",
    "gists_url": "https://api.github.com/users/k8s-github-robot/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/k8s-github-robot",
    "id": 13653959,
    "login": "k8s-github-robot",
    "node_id": "MDQ6VXNlcjEzNjUzOTU5",
    "organizations_url": "https://api.github.com/users/k8s-github-robot/orgs",
    "received_events_url": "https://api.github.com/users/k8s-github-robot/received_events",
    "repos_url": "https://api.github.com/users/k8s-github-robot/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/k8s-github-robot/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/k8s-github-robot/subscriptions",
    "type": "User",
    "url": "https://api.github.com/users/k8s-github-robot"
  },
  "comments": 12,
  "comments_url": "https://api.github.com/repos/kubernetes/kubernetes/issues/43605/comments",
  "created_at": "2017-03-24T03:45:12Z",
  "events_url": "https://api.github.com/repos/kubernetes/kubernetes/issues/43605/events",
  "html_url": "https://github.com/kubernetes/kubernetes/issues/43605",
  "id": 216636844,
  "labels": [
    {
      "color": "e11d21",
      "default": false,
      "description": "Categorizes issue or PR as related to a bug.",
      "id": 105146071,
      "name": "kind/bug",
      "node_id": "MDU6TGFiZWwxMDUxNDYwNzE=",
      "url": "https://api.github.com/repos/kubernetes/kubernetes/labels/kind/bug"
    },
    {
      "color": "d2b48c",
      "default": false,
      "description": "Categorizes an issue or PR as relevant to SIG API Machinery.",
      "id": 173493835,
      "name": "sig/api-machinery",
      "node_id": "MDU6TGFiZWwxNzM0OTM4MzU=",
      "url": "https://api.github.com/repos/kubernetes/kubernetes/labels/sig/api-machinery"
    }
  ],
  "labels_url": "https://api.github.com/repos/kubernetes/kubernetes/issues/43605/labels{/name}",
  "locked": false,
  "milestone": null,
  "node_id": "MDU6SXNzdWUyMTY2MzY4NDQ=",
  "number": 43605,
  "performed_via_github_app": null,
  "repository_url": "https://api.github.com/repos/kubernetes/kubernetes",
  "state": "closed",
  "title": "[Bug] threadSafeMap: the obj has already been removed\uff0c but index is still in it",
  "updated_at": "2017-10-02T21:17:12Z",
  "url": "https://api.github.com/repos/kubernetes/kubernetes/issues/43605",
  "user": {
    "avatar_url": "https://avatars1.githubusercontent.com/u/8132300?v=4",
    "events_url": "https://api.github.com/users/shenlanse/events{/privacy}",
    "followers_url": "https://api.github.com/users/shenlanse/followers",
    "following_url": "https://api.github.com/users/shenlanse/following{/other_user}",
    "gists_url": "https://api.github.com/users/shenlanse/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/shenlanse",
    "id": 8132300,
    "login": "shenlanse",
    "node_id": "MDQ6VXNlcjgxMzIzMDA=",
    "organizations_url": "https://api.github.com/users/shenlanse/orgs",
    "received_events_url": "https://api.github.com/users/shenlanse/received_events",
    "repos_url": "https://api.github.com/users/shenlanse/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/shenlanse/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/shenlanse/subscriptions",
    "type": "User",
    "url": "https://api.github.com/users/shenlanse"
  }
}