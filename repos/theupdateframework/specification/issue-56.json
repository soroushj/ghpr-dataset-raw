{
  "active_lock_reason": null,
  "assignee": null,
  "assignees": [],
  "author_association": "CONTRIBUTOR",
  "body": "In section 5.1.3, the spec states:\r\n\r\n> 1.3. Check signatures. Version N+1 of the root metadata file MUST have been signed by: (1) a threshold of keys specified in the trusted root metadata file (version N), and (2) a threshold of keys specified in the new root metadata file being validated (version N+1). If version N+1 is not signed as required, discard it, abort the update cycle, and report the signature failure. On the next update cycle, begin at step 0 and version N of the root metadata file.\r\n\r\nHowever, this seems inconsistent with section 6.1 when speaking about recovering from a compromised root key:\r\n\r\n> To replace a compromised root key or any other top-level role key, the root role signs a new root.json file that lists the updated trusted keys for the role. When replacing root keys, an application will sign the new root.json file with both the new and old root keys. Any time such a change is required, the root.json file is versioned and accessible by version number, e.g., 3.root.json. Clients update the set of trusted root keys by requesting the current root.json and all previous root.json versions, until one is found that has been signed by a threshold of keys that the client already trusts. This is to ensure that outdated clients remain able to update, without requiring all previous root keys to be kept to sign new root.json metadata.\r\n\r\nAs best as I can tell, 5.1 suggests that you update the root metadata from N, to N+1, N+2, to N+M etc. But 6.1 looks like it says you figure out the latest root version, and walk backwards from N+M, N+M-1, N+M-2, etc until you find a root metadata that's been signed by a quorum of keys trusted by the version N metadata.\r\n\r\nIn this case, it seems like we could have clients with different strategies could end up trusting different roots. For example:\r\n\r\n* create a keys (K1) and sign root (R1) with them.\r\n* roll the root metadata (R2) with new keys (K2) and sign the metadata with K1 and K2.\r\n* we decide (R2) was compromised, so we generate (R3) and sign metadata with K1 and K3.\r\n\r\nSo a client thats updating from R1 with the forward updating updates to R2, and it will refuse to update to R3 because K2 didn't sign R3, but a client using the backwards strategy at R1 would skip R2 because R3 was signed by K1.\r\n\r\nLooking at [python-tuf](https://github.com/theupdateframework/tuf/blob/develop/tuf/client/updater.py#L1105)  implements the forward strategy. Is that the correct approach? If so, could section 6.1 be updated to reflect this?",
  "closed_at": "2019-11-15T14:49:27Z",
  "closed_by": {
    "avatar_url": "https://avatars2.githubusercontent.com/u/589324?v=4",
    "events_url": "https://api.github.com/users/lukpueh/events{/privacy}",
    "followers_url": "https://api.github.com/users/lukpueh/followers",
    "following_url": "https://api.github.com/users/lukpueh/following{/other_user}",
    "gists_url": "https://api.github.com/users/lukpueh/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/lukpueh",
    "id": 589324,
    "login": "lukpueh",
    "node_id": "MDQ6VXNlcjU4OTMyNA==",
    "organizations_url": "https://api.github.com/users/lukpueh/orgs",
    "received_events_url": "https://api.github.com/users/lukpueh/received_events",
    "repos_url": "https://api.github.com/users/lukpueh/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/lukpueh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/lukpueh/subscriptions",
    "type": "User",
    "url": "https://api.github.com/users/lukpueh"
  },
  "comments": 5,
  "comments_url": "https://api.github.com/repos/theupdateframework/specification/issues/56/comments",
  "created_at": "2019-10-22T22:02:11Z",
  "events_url": "https://api.github.com/repos/theupdateframework/specification/issues/56/events",
  "html_url": "https://github.com/theupdateframework/specification/issues/56",
  "id": 510947877,
  "labels": [],
  "labels_url": "https://api.github.com/repos/theupdateframework/specification/issues/56/labels{/name}",
  "locked": false,
  "milestone": null,
  "node_id": "MDU6SXNzdWU1MTA5NDc4Nzc=",
  "number": 56,
  "performed_via_github_app": null,
  "repository_url": "https://api.github.com/repos/theupdateframework/specification",
  "state": "closed",
  "title": "Ambiguity between section 5.1.3 and 6.1 regarding updating root keys",
  "updated_at": "2019-11-15T14:49:27Z",
  "url": "https://api.github.com/repos/theupdateframework/specification/issues/56",
  "user": {
    "avatar_url": "https://avatars3.githubusercontent.com/u/84711?v=4",
    "events_url": "https://api.github.com/users/erickt/events{/privacy}",
    "followers_url": "https://api.github.com/users/erickt/followers",
    "following_url": "https://api.github.com/users/erickt/following{/other_user}",
    "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/erickt",
    "id": 84711,
    "login": "erickt",
    "node_id": "MDQ6VXNlcjg0NzEx",
    "organizations_url": "https://api.github.com/users/erickt/orgs",
    "received_events_url": "https://api.github.com/users/erickt/received_events",
    "repos_url": "https://api.github.com/users/erickt/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/erickt/subscriptions",
    "type": "User",
    "url": "https://api.github.com/users/erickt"
  }
}